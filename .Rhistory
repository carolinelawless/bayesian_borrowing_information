4.14, 4.13, 4.07)
# Convert mm.ss to seconds
minutes <- floor(splits)
seconds <- round((splits - minutes) * 100)
pace_sec <- minutes * 60 + seconds
library(ggplot2)
df <- data.frame(
Kilometer = 1:length(pace_sec),
Pace = pace_sec
)
ggplot(df, aes(x = Kilometer, y = Pace)) +
geom_line(color = "#FC4C02", linewidth = 1) +
geom_point(color = "#FC4C02", size = 2) +
scale_x_continuous(breaks = df$Kilometer) +   # Show all x ticks
scale_y_continuous(
trans = "reverse",
labels = function(x) {
paste0(floor(x / 60), ":", sprintf("%02d", x %% 60))
}
) +
labs(
title = "",
x = "kilometer",
y = "pace (min/km)"
) +
theme_minimal(base_size = 14) +
theme(
plot.title = element_text(hjust = 0.5)
)
ggplot(df, aes(x = Kilometer, y = Pace)) +
geom_line(color = "#FC4C02", linewidth = 1) +
geom_point(color = "#FC4C02", size = 2) +
scale_x_continuous(breaks = df$Kilometer) +
scale_y_continuous(
trans = "reverse",
labels = function(x) {
paste0(floor(x / 60), ":", sprintf("%02d", x %% 60))
}
) +
labs(
title = "",
x = "kilometer",
y = "pace (min/km)"
) +
theme_minimal(base_size = 14) +
theme(
plot.title = element_text(hjust = 0.5),
axis.text.x = element_text(angle = 45, hjust = 1, size = 8)
)
ggplot(df, aes(x = Kilometer, y = Pace)) +
geom_line(color = "#FC4C02", linewidth = 1) +
geom_point(color = "#FC4C02", size = 2) +
scale_x_continuous(breaks = df$Kilometer) +
scale_y_continuous(
trans = "reverse",
labels = function(x) {
paste0(floor(x / 60), ":", sprintf("%02d", x %% 60))
}
) +
labs(
title = "",
x = "kilometer",
y = "pace (min/km)"
) +
theme_minimal(base_size = 14) +
theme(
plot.title = element_text(hjust = 0.5),
axis.text.x = element_text(size = 7)  # smaller font size
)
splits <- c(4.39, 4.32, 4.29, 4.29, 4.28, 4.27, 4.27, 4.22, 4.21, 4.24,
4.25, 4.19, 4.22, 4.19, 4.23, 4.20, 4.19, 4.22, 4.18, 4.22,
4.18, 4.18, 4.21, 4.27, 4.17, 4.20, 4.21, 4.14, 4.14, 4.06,
4.01, 4.03, 4.16, 4.18, 4.17, 4.11, 4.10, 4.13, 4.07, 4.03,
4.14, 4.13, 4.07)
# Convert mm.ss to seconds
minutes <- floor(splits)
seconds <- round((splits - minutes) * 100)
pace_sec <- minutes * 60 + seconds
library(ggplot2)
df <- data.frame(
Kilometer = 1:length(pace_sec),
Pace = pace_sec
)
ggplot(df, aes(x = Kilometer, y = Pace)) +
geom_line(color = "#FC4C02", linewidth = 1) +
geom_point(color = "#FC4C02", size = 2) +
scale_x_continuous(breaks = seq(5, max(df$Kilometer), by = 5)) +  # only multiples of 5
scale_y_continuous(
trans = "reverse",
labels = function(x) {
paste0(floor(x / 60), ":", sprintf("%02d", x %% 60))
}
) +
labs(
title = "",
x = "km",
y = "pace (min/km)"
) +
theme_minimal(base_size = 14) +
theme(
plot.title = element_text(hjust = 0.5)
)
remove(list = ls())
setwd("/Users/clawless/Documents/MediTwin/bayesian_borrowing_information")
source("TEA_functions.R")
n <- 1e2
# Simulate under H0 (same params for all datasets)
S_H0_1_all <- simulate_S(rep(0.01, 5), n)
S_H0_2_all <- simulate_S(rep(0.5, 5), n)
S_H0_2 <- S_H0_2_all[[1]]
epsilons_H0_2 <- S_H0_2_all[[2]]
threshold2 <- quantile(S_H0_2, 0.05)  # 5% quantile for 5% false positive rate
S_H0_2
threshold2 <- quantile(S_H0_2, 0.05)  # 5% quantile for 5% false positive rate
threshold2 #2.74
S_H0_2_all <- simulate_S(rep(0.5, 5), n)
S_H0_2 <- S_H0_2_all[[1]]
epsilons_H0_2 <- S_H0_2_all[[2]]
threshold2 <- quantile(S_H0_2, 0.05)  # 5% quantile for 5% false positive rate
threshold2 #2.74
S_H0_2_all <- simulate_S(rep(0.5, 5), n)
S_H0_2 <- S_H0_2_all[[1]]
epsilons_H0_2 <- S_H0_2_all[[2]]
threshold2 <- quantile(S_H0_2, 0.05)  # 5% quantile for 5% false positive rate
threshold2 #2.74
S_H0_2_all <- simulate_S(rep(0.5, 5), n)
S_H0_2 <- S_H0_2_all[[1]]
epsilons_H0_2 <- S_H0_2_all[[2]]
threshold2 <- quantile(S_H0_2, 0.05)  # 5% quantile for 5% false positive rate
threshold2 #2.74
S_H0_2_all <- simulate_S(rep(0.5, 5), n)
S_H0_2 <- S_H0_2_all[[1]]
epsilons_H0_2 <- S_H0_2_all[[2]]
threshold2 <- quantile(S_H0_2, 0.05)  # 5% quantile for 5% false positive rate
threshold2 #2.74
S_H0_2_all <- simulate_S(rep(0.5, 5), n, nsim = 1e3)
S_H0_2_all <- simulate_S(rep(0.5, 5), n, M = 1e3, nsim = 1e3)
S_H0_2_all <- simulate_S(rep(0.5, 5), n, n_sim = 1e3)
S_H0_2 <- S_H0_2_all[[1]]
epsilons_H0_2 <- S_H0_2_all[[2]]
threshold2 <- quantile(S_H0_2, 0.05)  # 5% quantile for 5% false positive rate
threshold2 #2.74
# Simulate under H0 (same params for all datasets)
S_H0_1_all <- simulate_S(rep(0.01, 5), n)
S_H0_1 <- S_H0_1_all[[1]]
epsilons_H0_1 <- S_H0_1_all[[2]]
threshold1 <- quantile(S_H0_1, 0.05)  # 5% quantile for 5% false positive rate
S_H0_2_all <- simulate_S(rep(0.5, 5), n, n_sim = 1e3)
S_H0_2 <- S_H0_2_all[[1]]
epsilons_H0_2 <- S_H0_2_all[[2]]
threshold2 <- quantile(S_H0_2, 0.05)  # 5% quantile for 5% false positive rate
threshold2 #2.74
# Simulate under H1 (all params different)
params_H1_1 <- c(0.5, 0.55, 0.6, 0.65, 0.7)  # all params different
S_H1_1_all <- simulate_S(params_H1_1, n)
S_H1_1 <- S_H1_1_all[[1]]
epsilons_H1_1 <- S_H1_1_all[[2]]
epsilons_H1_1 #0.75, 0.68, 0.65, 0.64
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_1 < threshold))/length(S_H1_1)
threshold <- 2.7
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_1 < threshold))/length(S_H1_1)
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_1 < 2.6))/length(S_H1_1)
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_1 < 2.69))/length(S_H1_1)
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_1 < 2.72))/length(S_H1_1)
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_1 < 2.74))/length(S_H1_1)
# Simulate under H1 (all params different)
params_H1_1 <- c(0.5, 0.55, 0.6, 0.65, 0.7)  # all params different
S_H1_1_all <- simulate_S(params_H1_1, n, n_sim = 1e3)
S_H1_1 <- S_H1_1_all[[1]]
epsilons_H1_1 <- S_H1_1_all[[2]]
epsilons_H1_1 #0.75, 0.68, 0.65, 0.64
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_1 < threshold))/length(S_H1_1)
threshold
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_1 < 2.74))/length(S_H1_1)
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_1 < 2.68))/length(S_H1_1)
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_1 < 2.71))/length(S_H1_1)
# Simulate under H1 (last param different)
params_H1_2 <- c(0.5, 0.5, 0.5, 0.5, 0.7)  # last param different
S_H1_2_all <- simulate_S(params_H1_2, n)
S_H1_2 <- S_H1_2_all[[1]]
epsilons_H1_2 <- S_H1_2_all[[2]]
epsilons_H1_2 #0.77, 0.78, 0.79, 0.23
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_1 < threshold))/length(S_H1_2)
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_2 < threshold))/length(S_H1_2)
# Simulate under H1 (last param different)
params_H1_2 <- c(0.5, 0.5, 0.5, 0.5, 0.7)  # last param different
S_H1_2_all <- simulate_S(params_H1_2, n, n_sim = 1e3)
S_H1_2 <- S_H1_2_all[[1]]
epsilons_H1_2 <- S_H1_2_all[[2]]
epsilons_H1_2 #0.77, 0.78, 0.79, 0.23
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_2 < threshold))/length(S_H1_2) #0.76
length(which(S_H1_2 < threshold))/length(S_H0_2)
# Simulate under H1 (all params different)
params_H1_1 <- c(0.5, 0.55, 0.6, 0.65, 0.7)  # all params different
S_H1_1_all <- simulate_S(params_H1_1, n, n_sim = 1e3)
S_H1_1 <- S_H1_1_all[[1]]
epsilons_H1_1 <- S_H1_1_all[[2]]
epsilons_H1_1 #0.75, 0.68, 0.65, 0.64
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_1 < threshold))/length(S_H1_1) #0.491
# Simulate under H1 (last param different)
params_H1_2 <- c(0.5, 0.5, 0.5, 0.5, 0.7)  # last param different
S_H1_2_all <- simulate_S(params_H1_2, n, n_sim = 1e3)
S_H1_2 <- S_H1_2_all[[1]]
epsilons_H1_2 <- S_H1_2_all[[2]]
epsilons_H1_2 #0.77, 0.78, 0.79, 0.23
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_2 < threshold))/length(S_H1_2) #0.76 0.723
# Simulate under H1 (all params different)
params_H1_1 <- c(0.5, 0.55, 0.6, 0.65, 0.7)  # all params different
S_H1_1_all <- simulate_S(params_H1_1, n, n_sim = 1e3)
S_H1_1 <- S_H1_1_all[[1]]
epsilons_H1_1 <- S_H1_1_all[[2]]
epsilons_H1_1 #0.75, 0.68, 0.65, 0.64
# Check how often S_H1 < threshold to estimate power
length(which(S_H1_1 < threshold))/length(S_H1_1) #0.491 #0.461
#########################################################################
# Hierarchical commensurate prior for multiple historical binomial datasets
#########################################################################
remove(list = ls())
library(rjags)
library(coda)
library(parallel)
model_string <- "
model {
for (j in 1:J) {
for (i in 1:n) {
y[j,i] ~ dbern(params[j])
}
}
for (j in 1:J) {
logit(params[j]) <- theta[j]
}
theta[1] ~ dnorm(0, 0.01)
for (j in 2:J) {
theta[j] ~ dnorm(theta[j-1], tau[j])
}
for (j in 2:J) {
sigma[j] ~ dunif(0, 5)
tau[j] <- pow(sigma[j], -2)
}
}
"
#jags_sampler <- function(params, n, model_string){
jags_sampler <- function(y, n, model_string){
J <- nrow(y)
# # --- Simulate data ---
# y <- matrix(NA, nrow = J, ncol = n)
# for(j in 1:J){
#   y[j, ] <- rbinom(n, 1, params[j])
# }
# --- JAGS data list ---
data_jags <- list(
y = y,
n = n,
J = J
)
# --- Build model ---
model <- jags.model(
textConnection(model_string),
data = data_jags,
n.chains = 3,
n.adapt = 1000
)
# Burn-in
update(model, 1000)
# Sample
samples <- coda.samples(
model,
variable.names = c(
"params",
"theta",
"tau"
),
n.iter = 10000
)
samples_mat <- as.matrix(samples)
return(samples_mat)
}
# --- Simulate data ---
params <- rep(0.5, 5)
J <- length(params)
n <- 1e2
y <- matrix(NA, nrow = J, ncol = n)
for(j in 1:J){
y[j, ] <- rbinom(n, 1, params[j])
}
remove(list = ls())
library(rjags)
library(coda)
library(parallel)
model_string <- "
model {
for (j in 1:J) {
for (i in 1:n) {
y[j,i] ~ dbern(params[j])
}
}
for (j in 1:J) {
logit(params[j]) <- theta[j]
}
theta[1] ~ dnorm(0, 0.01)
for (j in 2:J) {
theta[j] ~ dnorm(theta[j-1], tau[j])
}
for (j in 2:J) {
sigma[j] ~ dunif(0, 5)
tau[j] <- pow(sigma[j], -2)
}
}
"
#jags_sampler <- function(params, n, model_string){
jags_sampler <- function(y, n, model_string){
J <- nrow(y)
# # --- Simulate data ---
# y <- matrix(NA, nrow = J, ncol = n)
# for(j in 1:J){
#   y[j, ] <- rbinom(n, 1, params[j])
# }
# --- JAGS data list ---
data_jags <- list(
y = y,
n = n,
J = J
)
# --- Build model ---
model <- jags.model(
textConnection(model_string),
data = data_jags,
n.chains = 3,
n.adapt = 1000
)
# Burn-in
update(model, 1000)
# Sample
samples <- coda.samples(
model,
variable.names = c(
"params",
"theta",
"tau"
),
n.iter = 10000
)
samples_mat <- as.matrix(samples)
return(samples_mat)
}
# --- Simulate data ---
params <- rep(0.5, 5)
J <- length(params)
n <- 1e2
y <- matrix(NA, nrow = J, ncol = n)
for(j in 1:J){
y[j, ] <- rbinom(n, 1, params[j])
}
simulate_S <- function(params, n, n_sim = 1e3){
S_vals <- numeric(n_sim)
J <- length(params)
for(i in 1:n_sim){
print(i)
y <- matrix(NA, nrow = J, ncol = n)
for(j in 1:J){
y[j, ] <- rbinom(n, 1, params[j])
}
samples_mat <- jags_sampler(y, n, model_string)
S <- 0
for(j in 2:J){
S <- S + mean(samples_mat[, paste0("tau[",j,"]")])
}
S_vals[i] <- S
}
return(S_vals)
}
t1 <- proc.time()
# Simulate under H0 (same params for all datasets)
S_H0 <- simulate_S(rep(0.5, 5), n)
threshold <- quantile(S_H0, 0.05)  # 5% quantile for 5% false positive rate
threshold #20442 21775 17194 1991 (1e3 simulations)
t2 <- proc.time()
t2 - t1
2523/60
# Simulate under H1 (last param different)
params_H1 <- c(0.5, 0.5, 0.5, 0.5, 0.7)  # last dataset different
S_H1 <- simulate_S(params_H1, n)
# You can check how often S_H1 < threshold to estimate power
length(which(S_H1 < threshold))/length(S_H1)
t2 <- proc.time()
t2 - t1
# You can check how often S_H1 < threshold to estimate power
length(which(S_H1 < threshold))/length(S_H1)
4565/60
# Simulate under H1
params_H1 <- c(0.5, 0.56, 0.6, 0.65, 0.7)
S_H1 <- simulate_S(params_H1, n)
# You can check how often S_H1 < threshold to estimate power
length(which(S_H1 < threshold))/length(S_H1)
t2 <- proc.time()
t2 - t1
7742/60
# Simulate under H1 (last param different)
params_H1 <- c(0.5, 0.5, 0.5, 0.5, 0.9)  # last dataset different
S_H1 <- simulate_S(params_H1, n)
# You can check how often S_H1 < threshold to estimate power
length(which(S_H1 < threshold))/length(S_H1)
t2 <- proc.time()
t2 - t1
9803/60
# Simulate under H1
params_H1 <- c(0.5, 0.6, 0.7, 0.8, 0.9)
S_H1 <- simulate_S(params_H1, n)
# You can check how often S_H1 < threshold to estimate power
length(which(S_H1 < threshold))/length(S_H1)
t2 <- proc.time()
t2 - t1
12075/60
# Simulate under H1 (last param different)
params_H1 <- c(0.5, 0.5, 0.5, 0.5, 0.9)  # last dataset different
S_H1 <- simulate_S(params_H1, n)
# You can check how often S_H1 < threshold to estimate power
length(which(S_H1 < threshold))/length(S_H1) #0.147
t2 <- proc.time()
t2 - t1
# Simulate under H1 (last param different)
params_H1 <- c(0.5, 0.5, 0.5, 0.5, 0.7)  # last dataset different
S_H1 <- simulate_S(params_H1, n)
# You can check how often S_H1 < threshold to estimate power
length(which(S_H1 < threshold))/length(S_H1) #0.124
t2 <- proc.time()
t2 - t1
pwd
ls
return("R test!")
print("R test!")
pwd
getwd()
remove(list = ls())
setwd("/Users/clawless/Documents/MediTwin/bayesian_borrowing_information")
source("TEA_functions.R")
n <- 1e2
S_H0_all <- simulate_S(rep(0.5, 5), n, n_sim = 1e2)
S_H0 <- S_H0_all[[1]]
epsilons_H0 <- S_H0_2_all[[2]]
epsilons_H0 <- S_H0_all[[2]]
threshold <- quantile(S_H0, 0.05)  # 5% quantile for 5% false positive rate
threshold
remove(list = ls())
setwd("/Users/clawless/Documents/MediTwin/bayesian_borrowing_information")
source("TEA_functions.R")
n <- 1e2
S_H0_all <- simulate_S(rep(0.5, 5), n, n_sim = 1e2)
S_H0 <- S_H0_all[[1]]
epsilons_H0 <- S_H0_all[[2]]
threshold <- quantile(S_H0, 0.05)  # 5% quantile for 5% false positive rate
# Simulate under H1 (all params different)
params_H1_1 <- c(0.5, 0.55, 0.6, 0.65, 0.7)  # all params different
S_H1_1_all <- simulate_S(params_H1_1, n, n_sim = 1e2)
S_H1_1 <- S_H1_1_all[[1]]
epsilons_H1_1 <- S_H1_1_all[[2]]
epsilons_H1_1 #0.75, 0.68, 0.65, 0.64
# Check how often S_H1 < threshold to estimate power
power1 <- length(which(S_H1_1 < threshold))/length(S_H1_1) #0.491 #0.461 0.461
# Simulate under H1 (last param different)
params_H1_2 <- c(0.5, 0.5, 0.5, 0.5, 0.7)  # last param different
S_H1_2_all <- simulate_S(params_H1_2, n, n_sim = 1e2)
S_H1_2 <- S_H1_2_all[[1]]
epsilons_H1_2 <- S_H1_2_all[[2]]
epsilons_H1_2 #0.77, 0.78, 0.79, 0.23
# Check how often S_H1 < threshold to estimate power
power2 <- length(which(S_H1_2 < threshold))/length(S_H1_2) #0.76 0.723 0.71
power1
power2
remove(list = ls())
remove(list = ls())
setwd("/Users/clawless/Documents/MediTwin/bayesian_borrowing_information")
source("TEA_functions.R")
n <- 1e2
nsim <- 50
S_H0_all <- simulate_S(rep(0.5, 5), n, n_sim = nsim)
S_H0 <- S_H0_all[[1]]
epsilons_H0 <- S_H0_all[[2]]
threshold <- quantile(S_H0, 0.05)  # 5% quantile for 5% false positive rate
# Simulate under H1 (all params different)
params_H1_1 <- c(0.5, 0.55, 0.6, 0.65, 0.7)  # all params different
S_H1_1_all <- simulate_S(params_H1_1, n, n_sim = nsim)
S_H1_1 <- S_H1_1_all[[1]]
epsilons_H1_1 <- S_H1_1_all[[2]]
epsilons_H1_1 #0.75, 0.68, 0.65, 0.64
# Check how often S_H1 < threshold to estimate power
power1 <- length(which(S_H1_1 < threshold))/length(S_H1_1) #0.491 #0.461 0.461
# Simulate under H1 (last param different)
params_H1_2 <- c(0.5, 0.5, 0.5, 0.5, 0.7)  # last param different
S_H1_2_all <- simulate_S(params_H1_2, n, n_sim = nsim)
S_H1_2 <- S_H1_2_all[[1]]
epsilons_H1_2 <- S_H1_2_all[[2]]
epsilons_H1_2 #0.77, 0.78, 0.79, 0.23
# Check how often S_H1 < threshold to estimate power
power2 <- length(which(S_H1_2 < threshold))/length(S_H1_2) #0.76 0.723 0.71
power1
power2
